{-# LANGUAGE CPP #-}
--------------------------------------------------------------------------------
-- |
-- Module    : Protein
-- Copyright : (c) 2009 Trevor L. McDonell
-- License   : BSD
--
-- Utilities for protein sequences and peptide fragments
--
--------------------------------------------------------------------------------


module Protein
  (
    Peptide(..),
    Protein(..),
    ProteinDatabase,

    readFasta,
    digestProtein,

    pmass, name, description, slice,
--    bIonLadder, yIonLadder
  )
  where

import Mass
import Config
import Kernels

import Data.List
import qualified Bio.Sequence as S
import qualified Data.ByteString.Lazy.Char8 as L

import C2HS
import Foreign.CUDA (DevicePtr)
import qualified Foreign.CUDA as G


--------------------------------------------------------------------------------
-- Data Structures
--------------------------------------------------------------------------------

type ProteinDatabase = [Protein]

--
-- A protein, represented by its amino acid character code sequence
--
data Protein = Protein
    {
        header    :: L.ByteString,      -- Description of the protein
        seqdata   :: L.ByteString,      -- Amino acid character sequence
        bions     :: DevicePtr CFloat,  -- Sequence ladder of b-ion series fragments
        yions     :: DevicePtr CFloat,  -- y-ion series fragments
        fragments :: [Peptide]          -- Peptide fragments digested from this protein
    }
    deriving (Eq, Show)

--
-- Extract the name and full description of a protein
--
name, description :: Protein -> String
name        = L.unpack . head . L.words . header
description = L.unpack . header

--
-- A subsequence of a protein. Copy the bytestring sequence so that the garbage
-- collector might recover the much larger parent protein.
--
data Peptide = Peptide
    {
        parent    :: Protein,           -- Protein this fragment derives from
        residual  :: Float,             -- The sum of the residual masses of this peptide
        offset    :: Int64,
        terminals :: (Int64, Int64)     -- Location in the parent protein of this peptide
    }
    deriving (Eq, Show)

--
-- The mass of the peptide is the sum of the amino acid residue masses plus the
-- mass of the water molecule released in forming the peptide bond (plus one;
-- from Eq. 1 of Eng.[1])
--
pmass   :: Peptide -> Float
pmass p =  residual p + (massH2O + massH)

--
-- Lyse the parent to extract the amino acid sequence of this peptide
--
lyse :: Peptide -> L.ByteString
lyse pep = seqextract ((seqdata . parent) pep) . terminals $ pep

seqextract :: L.ByteString -> (Int64,Int64) -> L.ByteString
seqextract b (c,n) = L.take (n-c+1) . L.drop c $ b


#if 0
--
-- The mass ladder generated by successive breaks of the peptide backbone from
-- the C- to N-terminus. This calculates the total residual mass and B-ion
-- ladder in one pass, so maybe we can be clever and keep the second result
-- around just in case...
--
-- Be strict in the calculation of the residual mass, but not strict in the pair
-- constructor (so no foldl'), or in the list construction. Maybe...
--
massLadder :: ConfigParams -> Peptide -> (Float, [Float])
massLadder cp = L.foldl fn (0,[0]) . seqextract
    where
        fn (m,ll) a = let n = m + getAAMass cp a
                      in  n `seq` (n, ll++[n])

bIonLadder :: Peptide -> [Float]
bIonLadder =  init . tail . ladder

yIonLadder   :: Peptide -> [Float]
yIonLadder p =  (map (\x -> residual p - x) . bIonLadder) p
#endif

--------------------------------------------------------------------------------
-- File Handlers
--------------------------------------------------------------------------------

--
-- Read a protein database from a Fasta formatted file
--
-- Each entry consists of a header (with a prefix of >) followed by a series of
-- lines containing the sequence data.
--
readFasta :: FilePath -> IO ProteinDatabase
readFasta fasta = do
    database <- S.readFasta fasta
    return   $  map (\(S.Seq h d _) -> Protein h d undefined undefined []) database


--------------------------------------------------------------------------------
-- Protein Fragments
--------------------------------------------------------------------------------

--
-- Scan a protein sequence from the database looking for combinations of amino
-- acids, proceeding from the N to the C terminus.
--
-- Fragments are generated between each of the given list of amino acids where
-- cleavage occurs, and attached to the input protein.
--
-- This almost supports special digestion rules...
--
-- TODO:
--  - Copy the character code sequences and perform the mass lookup on the device?
--  - Perform on-device filtering with map and compact/bpermute?
--
digestProtein :: ConfigParams -> Protein -> IO Protein
digestProtein cp protein =
  --
  -- Copy all necessary data to the device, and allocate some temporary storage
  -- as well. From the host, we copy the lengths of each individual segment,
  -- followed by the concatenation of the ion masses of each sequence.
  --
  G.withArrayLen lengths $ \num_seqs seq_lengths  ->
  G.withArrayLen masses  $ \num_ions ion_masses   ->
  G.allocaBytes (bytes num_seqs)     $ \offsets   ->
  G.allocaBytes (bytes num_seqs)     $ \residuals ->
  G.allocaBytes (bytes num_ions)     $ \flags     ->
  G.allocaBytes (bytes num_seqs)     $ \ones      -> do
  ladder_b <- G.forceEither `fmap` G.malloc (bytes num_ions)
  ladder_y <- G.forceEither `fmap` G.malloc (bytes num_ions)
  G.memset flags (bytes num_ions) 0

  --
  -- Scan the sequence lengths to find the offset of that sequence in the
  -- concatenated array. Permute into these locations in the flags array a `1',
  -- which then demarcates the start of each segment.
  --
  scanl_plusui seq_lengths offsets num_seqs
  replicate_ui ones 1 num_seqs
  permute_ui ones flags offsets num_seqs

  --
  -- The mass ladder generated by successive breaks of the peptide backbone from
  -- the C- to N- terminus. Also extract the total residual mass of each
  -- sequence.
  --
  scanl1Seg_plusf ion_masses flags ladder_b num_ions
  scanr1Seg_plusf ion_masses flags ladder_y num_ions
  bpermute_f ladder_y residuals offsets num_seqs

  --
  -- Read back and package the results
  --
  r_off <- (map cIntConv   . G.forceEither) `fmap` G.peekArray num_seqs offsets
  r_res <- (map cFloatConv . G.forceEither) `fmap` G.peekArray num_seqs residuals

  return $ let p = protein { bions = ladder_b, yions = ladder_y }
           in  p { fragments = filter inrange $ zipWith3 (Peptide p) r_res r_off splices }
  where
    inrange p = minPeptideMass cp <= pmass p && pmass p <= maxPeptideMass cp
    bytes x   = fromIntegral x * fromIntegral (sizeOf (undefined::CFloat))

    indices   = L.findIndices ((fst . digestionRule) cp) (seqdata protein)
    splices   = simpleSplice cp . simpleFragment protein $ indices

    lengths   = map (\(m,n) -> cIntConv (n - m + 1)) splices
    ions      = foldl' (\a -> L.append a . seqextract (seqdata protein)) L.empty $ splices
    masses    = map (cFloatConv . getAAMass cp) . L.unpack $ ions


--
-- Split a protein at the given amino acid locations. Be sure to include the
-- final fragment, with a dummy cleavage point at the end of the sequence.
--
simpleFragment :: Protein -> [Int64] -> [(Int64,Int64)]
simpleFragment protein indices =
  zip (-1:indices) (indices ++ [L.length (seqdata protein) -1])


--
-- Include the possibility of a number of missed cleavages. All combinations of
-- [0..n] sequential peptides are joined. For example, with two missed
-- cleavages:
--      simpleSplice [a,b,c] -> [a,a:b,a:b:c, b,b:c, c]
--
-- The input list must consist of sorted and adjacent breaks of the original
-- protein sequence, but the output is unordered.
--
simpleSplice :: ConfigParams -> [(Int64,Int64)] -> [(Int64,Int64)]
simpleSplice cp = go
  where
    go []         = []
    go idx@(i:is) = map (splice i) (take n idx) ++ go is

    n             = missedCleavages cp + 1
    splice a b    = (fst a + 1, snd b)


#if 0
--
-- Record a new protein fragment by lysing the parent protein at the given amino
-- acid locations.
--
fragment :: ConfigParams -> Protein -> (Int64, Int64) -> Peptide
fragment cp protein indices = pep
    where
        (m,l) = massLadder cp pep
        pep   = Peptide
          {
            parent     = protein,
            residual   = m,
            ladder     = l,
            terminals  = indices
          }


--
-- Scan a protein sequence from the database looking for combinations of amino
-- acids, proceeding from the N to the C terminus.
--
-- Fragments are generated between each of the given list of amino acids where
-- cleavage occurs, and attached to the input protein.
--
-- This almost supports special digestion rules...
--
digestProtein :: ConfigParams -> Protein -> Protein
digestProtein cp protein = protein { fragments = seqs }
    where
        seqs      = filter inrange splices
        inrange p = minPeptideMass cp <= pmass p && pmass p <= maxPeptideMass cp

        indices   = L.findIndices ((fst.digestionRule) cp) (seqdata protein)
        frags     = simpleFragment cp protein (-1:indices)
        splices   = simpleSplice cp frags


--
-- Split a protein at the given amino acid locations. Be sure to include the
-- final fragment, with a dummy cleavage point at the end of the sequence.
--
simpleFragment :: ConfigParams -> Protein -> [Int64] -> [Peptide]
simpleFragment _  _ []     = []
simpleFragment cp p (i:is)
    | i+1 > n              = []
    | otherwise            = fragment cp p (i+1, n) : simpleFragment cp p is
    where n = if null is
                then L.length (seqdata p) - 1
                else head is


--
-- Include the possibility of a number of missed cleavages. All combinations of
-- [0..n] sequential peptides are joined. For example, with two missed
-- cleavages:
--      simpleSplice [a,b,c] -> [a,a:b,a:b:c, b,b:c, c]
--
-- The input list must consist of sorted and adjacent breaks of the original
-- protein sequence, but the output is unordered.
--
simpleSplice :: ConfigParams -> [Peptide] -> [Peptide]
simpleSplice _  []         = []
simpleSplice cp pep@(p:ps)
    | null ps              = [p]
    | otherwise            = scanl1 splice (take n pep) ++ simpleSplice cp ps
    where
        n          = missedCleavages cp + 1
        splice a b = Peptide
          {
            parent    = parent a,
            residual  = residual a + residual b,
            ladder    = ladder a ++ map (+residual a) (ladder b),
            terminals = (fst (terminals a), snd (terminals b))
          }
#endif

--------------------------------------------------------------------------------
-- Pretty printing
--------------------------------------------------------------------------------

--
-- Return a representation of the amino acid sequence of a peptide, including
-- the flanking residuals (if present)
--
slice :: Peptide -> String
slice peptide = [ca,'.'] ++ (L.unpack (lyse peptide)) ++ ['.',na]
    where
        chain = seqdata (parent peptide)
        (c,n) = terminals peptide
        l     = L.length chain - 2
        ca    = if c > 0 then L.index chain (c-1) else '-'
        na    = if n < l then L.index chain (n+1) else '-'

