{-
 - Utilities for protein sequences and peptide fragments
 -}


module Protein where

import Config
import AminoAcid

import Data.Int
import Data.List
import qualified Bio.Sequence as S
import qualified Data.ByteString.Lazy.Char8 as L


--------------------------------------------------------------------------------
-- Data Structures
--------------------------------------------------------------------------------

type ProteinDatabase = [Protein]

--
-- A protein, represented by its amino acid character code sequence
--
data Protein = Protein
    {
        header    :: L.ByteString,      -- Description of the protein
        seqdata   :: L.ByteString,      -- Amino acid character sequence
        fragments :: [Peptide]          -- Peptide fragments digested from this protein
    }
    deriving (Eq, Show)

--
-- Extract the name and full description of a protein
--
name, description :: Protein -> String
name        = L.unpack . head . L.words . header
description = L.unpack . header

--
-- A subsequence of a protein. Copy the bytestring sequence so that the garbage
-- collector might recover the much larger parent protein.
--
data Peptide = Peptide
    {
        parent    :: Protein,           -- Protein this fragment derives from
        residual  :: Float,             -- The sum of the residual masses of this peptide
        ladder    :: [Float],           -- Sequence ladder of b-ion series fragments
        terminals :: (Int64, Int64)     -- Location in the parent protein of this peptide
    }
    deriving (Eq, Show)

--
-- The mass of the peptide is the sum of the amino acid residue masses plus the
-- mass of the water molecule released in forming the peptide bond (plus one;
-- from Eq. 1 of Eng.[1])
--
pmass   :: Peptide -> Float
pmass p =  residual p + (massH2O + massH)

--
-- Lyse the parent to extract the amino acid sequence of this peptide
--
seqextract :: Peptide -> L.ByteString
seqextract pep   = (L.take (n-c+1) . L.drop c . seqdata . parent) pep
    where  (c,n) = terminals pep

--
-- The mass ladder generated by successive breaks of the peptide backbone from
-- the C- to N-terminus. This calculates the total residual mass and B-ion
-- ladder in one pass, so maybe we can be clever and keep the second result
-- around just in case...
--
-- Be strict in the calculation of the residual mass, but not strict in the pair
-- constructor (so no foldl'), or in the list construction. Maybe...
--
massLadder :: ConfigParams -> Peptide -> (Float, [Float])
massLadder cp = L.foldl fn (0,[0]) . seqextract
    where
        fn (m,ll) a = let n = m + getAAMass cp a
                      in  n `seq` (n, ll++[n])

bIonLadder :: Peptide -> [Float]
bIonLadder =  tail . ladder

yIonLadder   :: Peptide -> [Float]
yIonLadder p =  (init . map (\x -> residual p - x) . bIonLadder) p


--------------------------------------------------------------------------------
-- File Handlers
--------------------------------------------------------------------------------

--
-- Read a protein database from a Fasta formatted file
--
-- Each entry consists of a header (with a prefix of >) followed by a series of
-- lines containing the sequence data.
--
readFasta :: FilePath -> IO ProteinDatabase
readFasta fasta = do
    database <- S.readFasta fasta
    return   $  map (\(S.Seq h d _) -> Protein h d []) database


--------------------------------------------------------------------------------
-- Protein Fragments
--------------------------------------------------------------------------------

--
-- Record a new protein fragment by lysing the parent protein at the given amino
-- acid locations.
--
fragment :: ConfigParams -> Protein -> (Int64, Int64) -> Peptide
fragment cp protein indices = pep
    where
        (m,l) = massLadder cp pep
        pep   = Peptide
          {
            parent     = protein,
            residual   = m,
            ladder     = l,
            terminals  = indices
          }


--
-- Scan a protein sequence from the database looking for combinations of amino
-- acids, proceeding from the N to the C terminus.
--
-- Fragments are generated between each of the given list of amino acids where
-- cleavage occurs, and attached to the input protein.
--
-- This almost supports special digestion rules...
--
digestProtein :: ConfigParams -> Protein -> Protein
digestProtein cp protein = protein { fragments = seqs }
    where
        seqs      = filter inrange splices
        inrange p = minPeptideMass cp <= pmass p && pmass p <= maxPeptideMass cp

        indices   = L.findIndices ((fst.digestionRule) cp) (seqdata protein)
        frags     = simpleFragment cp protein (-1:indices)
        splices   = simpleSplice cp frags


--
-- Split a protein at the given amino acid locations. Be sure to include the
-- final fragment, with a dummy cleavage point at the end of the sequence.
--
simpleFragment :: ConfigParams -> Protein -> [Int64] -> [Peptide]
simpleFragment _  _ []     = []
simpleFragment cp p (i:is)
    | i+1 > n              = []
    | otherwise            = fragment cp p (i+1, n) : simpleFragment cp p is
    where n = if null is
                then L.length (seqdata p) - 1
                else head is


--
-- Include the possibility of a number of missed cleavages. All combinations of
-- [0..n] sequential peptides are joined. For example, with two missed
-- cleavages:
--      simpleSplice [a,b,c] -> [a,a:b,a:b:c, b,b:c, c]
--
-- The input list must consist of sorted and adjacent breaks of the original
-- protein sequence, but the output is unordered.
--
simpleSplice :: ConfigParams -> [Peptide] -> [Peptide]
simpleSplice _  []         = []
simpleSplice cp pep@(p:ps)
    | null ps              = [p]
    | otherwise            = scanl1 splice (take n pep) ++ simpleSplice cp ps
    where
        n          = missedCleavages cp + 1
        splice a b = Peptide
          {
            parent    = parent a,
            residual  = residual a + residual b,
            ladder    = ladder a ++ map (+residual a) (ladder b),
            terminals = (fst (terminals a), snd (terminals b))
          }


--------------------------------------------------------------------------------
-- Pretty printing
--------------------------------------------------------------------------------

--
-- Return a representation of the amino acid sequence of a peptide, including
-- the flanking residuals (if present)
--
slice :: Peptide -> String
slice peptide = [ca,'.'] ++ (L.unpack (seqextract peptide)) ++ ['.',na]
    where
        chain = seqdata (parent peptide)
        (c,n) = terminals peptide
        l     = L.length chain - 2
        ca    = if c > 0 then L.index chain (c-1) else '-'
        na    = if n < l then L.index chain (n+1) else '-'

