{-# LANGUAGE CPP #-}
--------------------------------------------------------------------------------
-- |
-- Module    : Protein
-- Copyright : (c) 2009 Trevor L. McDonell
-- License   : BSD
--
-- Utilities for protein sequences and peptide fragments
--
--------------------------------------------------------------------------------


module Protein
  (
    Peptide(..),
    Protein(..),
    ProteinDatabase,

    readFasta,
    digestProtein,

    pmass, name, description, slice,
--    bIonLadder, yIonLadder
  )
  where

import Mass
import Config
import Kernels

import Data.List
import qualified Bio.Sequence as S
import qualified Data.ByteString.Lazy.Char8 as L

import C2HS
import Foreign.CUDA (DevicePtr)
import qualified Foreign.CUDA as G


--------------------------------------------------------------------------------
-- Data Structures
--------------------------------------------------------------------------------

type ProteinDatabase = [Protein]

--
-- A protein, represented by its amino acid character code sequence
--
data Protein = Protein
    {
        header    :: L.ByteString,      -- Description of the protein
        seqdata   :: L.ByteString,      -- Amino acid character sequence
        seqmassL  :: DevicePtr CFloat,  -- Amino acid mass sequence (to the left, device)
        seqmassR  :: DevicePtr CFloat,  -- Amino acid mass sequence (to the right, device)
        fragments :: [Peptide]          -- Peptide fragments digested from this protein
    }
    deriving (Eq, Show)

--
-- Extract the name and full description of a protein
--
name, description :: Protein -> String
name        = L.unpack . head . L.words . header
description = L.unpack . header

--
-- A subsequence of a protein. Copy the bytestring sequence so that the garbage
-- collector might recover the much larger parent protein.
--
data Peptide = Peptide
    {
        parent    :: Protein,           -- Protein this fragment derives from
        residual  :: Float,             -- The sum of the residual masses of this peptide
--        ladder    :: [Float],           -- Sequence ladder of b-ion series fragments
        offset    :: Int64,
        terminals :: (Int64, Int64)     -- Location in the parent protein of this peptide
    }
    deriving (Eq, Show)

--
-- The mass of the peptide is the sum of the amino acid residue masses plus the
-- mass of the water molecule released in forming the peptide bond (plus one;
-- from Eq. 1 of Eng.[1])
--
pmass   :: Peptide -> Float
pmass p =  residual p + (massH2O + massH)

--
-- Lyse the parent to extract the amino acid sequence of this peptide
--
seqextract :: Peptide -> L.ByteString
seqextract pep = extent ((seqdata . parent) pep) . terminals $ pep

extent :: L.ByteString -> (Int64,Int64) -> L.ByteString
extent b (c,n) = L.take (n-c+1) . L.drop c $ b


#if 0
--
-- The mass ladder generated by successive breaks of the peptide backbone from
-- the C- to N-terminus. This calculates the total residual mass and B-ion
-- ladder in one pass, so maybe we can be clever and keep the second result
-- around just in case...
--
-- Be strict in the calculation of the residual mass, but not strict in the pair
-- constructor (so no foldl'), or in the list construction. Maybe...
--
massLadder :: ConfigParams -> Peptide -> (Float, [Float])
massLadder cp = L.foldl fn (0,[0]) . seqextract
    where
        fn (m,ll) a = let n = m + getAAMass cp a
                      in  n `seq` (n, ll++[n])

bIonLadder :: Peptide -> [Float]
bIonLadder =  init . tail . ladder

yIonLadder   :: Peptide -> [Float]
yIonLadder p =  (map (\x -> residual p - x) . bIonLadder) p
#endif

massLadder :: ConfigParams -> Protein -> [(Int64,Int64)] -> IO Protein
massLadder cp protein idx =
  G.withArrayLen flags $ \len d_flags ->
  G.withArray masses   $ \d_mass      -> do

  d_ladderL <- G.forceEither `fmap` G.malloc (bytes len)
  d_ladderR <- G.forceEither `fmap` G.malloc (bytes len)

  scanl1Seg_plusf d_mass d_flags d_ladderL len
  scanr1Seg_plusf d_mass d_flags d_ladderR len

  return $ protein { seqmassL = d_ladderL, seqmassR = d_ladderR }
  where
    bytes x = fromIntegral x * fromIntegral (sizeOf (undefined::Float))
    flags   = concatMap (\(m,n) -> 1 : replicate (fromIntegral (n-m)) 0) idx
    masses  = map (cFloatConv . getAAMass cp) . L.unpack $ acids
    acids   = foldl' (\a -> L.append a . extent (seqdata protein)) L.empty $ idx


massResidual :: DevicePtr CFloat -> [Int64] -> IO [Float]
massResidual d_ladder idx =
  G.withArrayLen idx'       $ \len d_idx -> do
  G.allocaBytes (bytes len) $ \d_res     -> do

  bpermute_f d_ladder d_res d_idx len
  (map cFloatConv . G.forceEither) `fmap` G.peekArray len d_res
  where
    idx'    = map cIntConv idx
    bytes x = fromIntegral x * fromIntegral (sizeOf (undefined::Float))


--------------------------------------------------------------------------------
-- File Handlers
--------------------------------------------------------------------------------

--
-- Read a protein database from a Fasta formatted file
--
-- Each entry consists of a header (with a prefix of >) followed by a series of
-- lines containing the sequence data.
--
readFasta :: FilePath -> IO ProteinDatabase
readFasta fasta = do
    database <- S.readFasta fasta
    return   $  map (\(S.Seq h d _) -> Protein h d undefined undefined []) database


--------------------------------------------------------------------------------
-- Protein Fragments
--------------------------------------------------------------------------------

digestProtein :: ConfigParams -> Protein -> IO Protein
digestProtein cp protein = do
  pro' <- massLadder cp protein splices
  resi <- massResidual (seqmassR pro') idx
  let p = zipWith3 (Peptide pro') resi idx splices

  return $ pro' { fragments = filter inrange p }
  where
    inrange p = minPeptideMass cp <= pmass p && pmass p <= maxPeptideMass cp

    indices   = L.findIndices ((fst . digestionRule) cp) (seqdata protein)
    frags     = simpleFragment protein indices
    splices   = simpleSplice cp frags
    idx       = init . scanl (\l (m,n) -> l+n-m+1) 0 $ splices


simpleFragment :: Protein -> [Int64] -> [(Int64,Int64)]
simpleFragment protein indices =
  zip (-1:indices) (indices ++ [L.length (seqdata protein) -1])


simpleSplice :: ConfigParams -> [(Int64,Int64)] -> [(Int64,Int64)]
simpleSplice cp = go
  where
    go []         = []
    go idx@(i:is) = map (splice i) (take n idx) ++ go is

    n             = missedCleavages cp + 1
    splice a b    = (fst a + 1, snd b)



#if 0
--
-- Record a new protein fragment by lysing the parent protein at the given amino
-- acid locations.
--
fragment :: ConfigParams -> Protein -> (Int64, Int64) -> Peptide
fragment cp protein indices = pep
    where
        (m,l) = massLadder cp pep
        pep   = Peptide
          {
            parent     = protein,
            residual   = m,
            ladder     = l,
            terminals  = indices
          }


--
-- Scan a protein sequence from the database looking for combinations of amino
-- acids, proceeding from the N to the C terminus.
--
-- Fragments are generated between each of the given list of amino acids where
-- cleavage occurs, and attached to the input protein.
--
-- This almost supports special digestion rules...
--
digestProtein :: ConfigParams -> Protein -> Protein
digestProtein cp protein = protein { fragments = seqs }
    where
        seqs      = filter inrange splices
        inrange p = minPeptideMass cp <= pmass p && pmass p <= maxPeptideMass cp

        indices   = L.findIndices ((fst.digestionRule) cp) (seqdata protein)
        frags     = simpleFragment cp protein (-1:indices)
        splices   = simpleSplice cp frags


--
-- Split a protein at the given amino acid locations. Be sure to include the
-- final fragment, with a dummy cleavage point at the end of the sequence.
--
simpleFragment :: ConfigParams -> Protein -> [Int64] -> [Peptide]
simpleFragment _  _ []     = []
simpleFragment cp p (i:is)
    | i+1 > n              = []
    | otherwise            = fragment cp p (i+1, n) : simpleFragment cp p is
    where n = if null is
                then L.length (seqdata p) - 1
                else head is


--
-- Include the possibility of a number of missed cleavages. All combinations of
-- [0..n] sequential peptides are joined. For example, with two missed
-- cleavages:
--      simpleSplice [a,b,c] -> [a,a:b,a:b:c, b,b:c, c]
--
-- The input list must consist of sorted and adjacent breaks of the original
-- protein sequence, but the output is unordered.
--
simpleSplice :: ConfigParams -> [Peptide] -> [Peptide]
simpleSplice _  []         = []
simpleSplice cp pep@(p:ps)
    | null ps              = [p]
    | otherwise            = scanl1 splice (take n pep) ++ simpleSplice cp ps
    where
        n          = missedCleavages cp + 1
        splice a b = Peptide
          {
            parent    = parent a,
            residual  = residual a + residual b,
            ladder    = ladder a ++ map (+residual a) (ladder b),
            terminals = (fst (terminals a), snd (terminals b))
          }
#endif

--------------------------------------------------------------------------------
-- Pretty printing
--------------------------------------------------------------------------------

--
-- Return a representation of the amino acid sequence of a peptide, including
-- the flanking residuals (if present)
--
slice :: Peptide -> String
slice peptide = [ca,'.'] ++ (L.unpack (seqextract peptide)) ++ ['.',na]
    where
        chain = seqdata (parent peptide)
        (c,n) = terminals peptide
        l     = L.length chain - 2
        ca    = if c > 0 then L.index chain (c-1) else '-'
        na    = if n < l then L.index chain (n+1) else '-'

