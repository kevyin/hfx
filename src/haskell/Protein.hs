--------------------------------------------------------------------------------
-- |
-- Module    : Protein
-- Copyright : (c) 2009 Trevor L. McDonell
-- License   : BSD
--
-- Utilities for protein sequences and peptide fragments
--
--------------------------------------------------------------------------------


module Protein
  (
    ProteinDatabase,  Protein(..),
    PeptideFragments, Peptide(..), lookupP,

    digestFasta,

    lyse, pmass, label, description, slice,
    bIonLadder, yIonLadder
  )
  where

import Mass
import Config

import Data.Int
import Data.Vector                                      (Vector)
import Data.Vector.Storable                             (Storable)
import Control.Monad                                    (foldM_)
import qualified Bio.Sequence                as F
import qualified Bio.Sequence.Fasta          as F
import qualified Data.ByteString.Lazy.Char8  as L

import qualified Data.Vector.Storable        as S
import qualified Data.Vector.Generic         as G
import qualified Data.Vector.Generic.Mutable as M


--------------------------------------------------------------------------------
-- Data Structures
--------------------------------------------------------------------------------

type ProteinDatabase a  = Vector (Protein a)
type PeptideFragments a = Vector (Peptide a)

--
-- A protein, represented by its amino acid character code sequence
--
data Protein a = Protein
  {
    seqheader :: L.ByteString,          -- Description of the protein
    seqdata   :: L.ByteString,          -- Amino acid character sequence
    fragments :: PeptideFragments a     -- Peptide fragments digested from this protein
  }
  deriving (Eq, Show)

--
-- Extract the name and full description of a protein
--
label, description :: Protein a -> String
label       = L.unpack . head . L.words . seqheader
description = L.unpack . seqheader


--
-- A subsequence of a protein. The key is currently just an array index, not a
-- unique identifier as such.
--
data Peptide a = Peptide
  {
    parentKey :: Int,                   -- Identifying "key" for the protein this fragment derives from
    residual  :: a,                     -- The sum of the residual masses of this peptide
    terminals :: (Int64, Int64)         -- Location in the parent protein of this peptide
  }
  deriving (Eq, Show)

lookupP :: ProteinDatabase a -> Peptide a -> Protein a
lookupP db p = db G.! parentKey p

--
-- The mass of the peptide is the sum of the amino acid residue masses plus the
-- mass of the water molecule released in forming the peptide bond (plus one;
-- from Eq. 1 of Eng.[1])
--
pmass :: Fractional a => Peptide a -> a
pmass p = residual p + (massH2O + massH)

--
-- Lyse (slice) the parent to extract the amino acid sequence of this peptide
--
lyse :: Protein a -> Peptide a -> L.ByteString
lyse pro pep = (L.take (n-c+1) . L.drop c . seqdata) pro
  where (c,n) = terminals pep

--
-- The mass ladder generated by successive breaks of the peptide backbone from
-- the C- to N-terminus. Don't include the last element of the sequence, which
-- corresponds to the mass of the unbroken peptide.
--
bIonLadder :: (Fractional a, Storable a)
           => ConfigParams a -> ProteinDatabase a -> Peptide a -> S.Vector a
bIonLadder cp db pep = G.scanl1' (+) $ G.generate (fromIntegral (L.length seqd)) gen
  where
    seqd = L.init (lyse (lookupP db pep) pep)
    gen  = getAAMass cp . L.index seqd . fromIntegral

yIonLadder :: (Fractional a, Storable a)
           => ConfigParams a -> ProteinDatabase a -> Peptide a -> S.Vector a
yIonLadder cp db pep = G.scanr1' (+) $ G.generate (fromIntegral (L.length seqd)) gen
  where
    seqd = L.tail (lyse (lookupP db pep) pep)
    gen  = getAAMass cp . L.index seqd . fromIntegral


--------------------------------------------------------------------------------
-- File Handlers
--------------------------------------------------------------------------------

--
-- Read a protein database from a Fasta formatted file
--
-- Each entry consists of a header (with a prefix of >) followed by a series of
-- lines containing the sequence data.
--
digestFasta :: (Storable a, Ord a, Fractional a)
            => ConfigParams a -> FilePath -> IO (ProteinDatabase a)
digestFasta cp fasta = do
  n    <- F.countSeqs fasta
  seqs <- F.readFasta fasta
  mv   <- M.unsafeNew n

  let fill i s = do
        let p = digestProtein cp i (Protein (F.seqheader s) (F.seqdata s) G.empty)
        M.unsafeWrite mv i p
        return (i+1)

  foldM_ fill 0 seqs
  G.unsafeFreeze mv


--------------------------------------------------------------------------------
-- Protein Fragments
--------------------------------------------------------------------------------

--
-- Record a new protein fragment by lysing the parent protein at the given amino
-- acid locations.
--
fragment :: (Fractional a, Storable a)
         => ConfigParams a -> Int -> Protein a -> (Int64, Int64) -> Peptide a
fragment cp idx pro term = pep
  where
    pep = Peptide idx res term
    res = L.foldl' (\m c -> m + getAAMass cp c) 0 (lyse pro pep)


--
-- Scan a protein sequence from the database looking for combinations of amino
-- acids, proceeding from the N to the C terminus.
--
-- Fragments are generated between each of the given list of amino acids where
-- cleavage occurs, and attached to the input protein.
--
-- This almost supports special digestion rules...
--
digestProtein :: (Fractional a, Ord a, Storable a)
              => ConfigParams a -> Int -> Protein a -> Protein a
digestProtein cp idx protein = seqs `seq` protein { fragments = seqs }
  where
    seqs      = G.fromList $ filter inrange splices
    inrange p = minPeptideMass cp <= pmass p && pmass p <= maxPeptideMass cp

    indices   = L.findIndices ((fst . digestionRule) cp) (seqdata protein)
    frags     = simpleFragment cp idx protein (-1:indices)
    splices   = simpleSplice cp frags


--
-- Split a protein at the given amino acid locations. Be sure to include the
-- final fragment, with a dummy cleavage point at the end of the sequence.
--
simpleFragment :: (Fractional a, Storable a)
               => ConfigParams a -> Int -> Protein a -> [Int64] -> [Peptide a]
simpleFragment cp idx p = loop
  where
    loop []                 = []
    loop (i:is) | i+1 > n   = []
                | otherwise = fragment cp idx p (i+1, n) : loop is
                where
                  l = L.length (seqdata p) - 1
                  n = if null is then l else head is


--
-- Include the possibility of a number of missed cleavages. All combinations of
-- [0..n] sequential peptides are joined. For example, with two missed
-- cleavages:
--      simpleSplice [a,b,c] -> [a,a:b,a:b:c, b,b:c, c]
--
-- The input list must consist of sorted and adjacent breaks of the original
-- protein sequence, but the output is unordered.
--
simpleSplice :: Num a => ConfigParams a -> [Peptide a] -> [Peptide a]
simpleSplice cp = loop
  where
    loop []     = []
    loop (p:ps) = scanl splice p (take n ps) ++ loop ps

    n           = missedCleavages cp
    splice a b  = Peptide
      {
        parentKey = parentKey a,
        residual  = residual a + residual b,
        terminals = (fst (terminals a), snd (terminals b))
      }


--------------------------------------------------------------------------------
-- Pretty printing
--------------------------------------------------------------------------------

--
-- Return a representation of the amino acid sequence of a peptide, including
-- the flanking residuals (if present)
--
slice :: Protein a -> Peptide a -> String
slice protein peptide = [ca,'.'] ++ (L.unpack (lyse protein peptide)) ++ ['.',na]
  where
    chain = seqdata protein
    (c,n) = terminals peptide
    l     = L.length chain - 2
    ca    = if c > 0 then L.index chain (c-1) else '-'
    na    = if n < l then L.index chain (n+1) else '-'

