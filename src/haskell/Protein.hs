--------------------------------------------------------------------------------
-- |
-- Module    : Protein
-- Copyright : (c) 2009 Trevor L. McDonell
-- License   : BSD
--
-- Utilities for protein sequences and peptide fragments
--
--------------------------------------------------------------------------------


module Protein
  (
    Peptide(..),
    Protein(..),

    digestFasta,

    lyse, pmass, label, description, slice,
    bIonLadder, yIonLadder
  )
  where

import Mass
import Config

import Data.Int
import Data.Vector                                      (Vector)
import Data.Vector.Storable                             (Storable)
import Control.Monad                                    (foldM_)
import qualified Bio.Sequence                as S
import qualified Bio.Sequence.Fasta          as S
import qualified Data.ByteString.Lazy.Char8  as L

import qualified Data.Vector.Storable        as U
import qualified Data.Vector.Generic         as G
import qualified Data.Vector.Generic.Mutable as M


--------------------------------------------------------------------------------
-- Data Structures
--------------------------------------------------------------------------------

--
-- A protein, represented by its amino acid character code sequence
--
data Protein a = Protein
  {
    seqheader :: L.ByteString,          -- Description of the protein
    seqdata   :: L.ByteString,          -- Amino acid character sequence
    fragments :: Vector (Peptide a)     -- Peptide fragments digested from this protein
  }
  deriving (Eq, Show)

--
-- Extract the name and full description of a protein
--
label, description :: Protein a -> String
label       = L.unpack . head . L.words . seqheader
description = L.unpack . seqheader

--
-- A subsequence of a protein. Copy the bytestring sequence so that the garbage
-- collector might recover the much larger parent protein.
--
data Peptide a = Peptide
  {
    parent    :: Protein a,             -- Protein this fragment derives from
    residual  :: a,                     -- The sum of the residual masses of this peptide
    terminals :: (Int64, Int64)         -- Location in the parent protein of this peptide
  }
  deriving (Eq, Show)

--
-- The mass of the peptide is the sum of the amino acid residue masses plus the
-- mass of the water molecule released in forming the peptide bond (plus one;
-- from Eq. 1 of Eng.[1])
--
pmass :: Fractional a => Peptide a -> a
pmass p = residual p + (massH2O + massH)

--
-- Lyse the parent to extract the amino acid sequence of this peptide
--
{-# INLINE lyse #-}
lyse :: Peptide a -> L.ByteString
lyse pep = (L.take (n-c+1) . L.drop c . seqdata . parent) pep
  where (c,n) = terminals pep


--
-- The mass ladder generated by successive breaks of the peptide backbone from
-- the C- to N-terminus. Don't include the last element of the sequence, which
-- corresponds to the mass of the unbroken peptide.
--
{-# INLINE bIonLadder #-}
bIonLadder :: (Fractional a, Storable a) => ConfigParams a -> Peptide a -> U.Vector a
bIonLadder cp pep = G.scanl1 (+) $ G.generate (fromIntegral (n-c)) gen
  where (c,n) = terminals pep
        seqd  = seqdata . parent $ pep
        gen i = getAAMass cp $ L.index seqd (c + fromIntegral i)


{-# INLINE yIonLadder #-}
yIonLadder :: (Fractional a, Storable a) => ConfigParams a -> Peptide a -> U.Vector a
yIonLadder cp pep = G.scanr1 (+) $ G.generate (fromIntegral (n-c)) gen
  where (c,n) = terminals pep
        seqd  = seqdata . parent $ pep
        gen i = getAAMass cp $ L.index seqd (c + 1 + fromIntegral i)


--------------------------------------------------------------------------------
-- File Handlers
--------------------------------------------------------------------------------

--
-- Read a protein database from a Fasta formatted file
--
-- Each entry consists of a header (with a prefix of >) followed by a series of
-- lines containing the sequence data.
--
digestFasta :: (Storable a, Ord a, Fractional a) => ConfigParams a -> FilePath -> IO (Vector (Protein a))
digestFasta cp fasta = do
  n    <- S.countSeqs fasta
  seqs <- S.readFasta fasta
  mv   <- M.unsafeNew n

  let fill i s = do
        let p = digestProtein cp (Protein (S.seqheader s) (S.seqdata s) G.empty)
        M.unsafeWrite mv i p
        return (i+1)

  foldM_ fill 0 seqs
  G.unsafeFreeze mv


--------------------------------------------------------------------------------
-- Protein Fragments
--------------------------------------------------------------------------------

--
-- Record a new protein fragment by lysing the parent protein at the given amino
-- acid locations.
--
fragment :: (Fractional a, Storable a) => ConfigParams a -> Protein a -> (Int64, Int64) -> Peptide a
fragment cp protein indices = pep
  where
    pep = Peptide {
        parent    = protein,
        residual  = L.foldl' (\m c -> m + getAAMass cp c) 0 (lyse pep),
        terminals = indices
      }

--
-- Scan a protein sequence from the database looking for combinations of amino
-- acids, proceeding from the N to the C terminus.
--
-- Fragments are generated between each of the given list of amino acids where
-- cleavage occurs, and attached to the input protein.
--
-- This almost supports special digestion rules...
--
digestProtein :: (Fractional a, Ord a, Storable a) => ConfigParams a -> Protein a -> Protein a
digestProtein cp protein = protein { fragments = seqs }
  where
    seqs      = G.filter inrange splices
    inrange p = minPeptideMass cp <= pmass p && pmass p <= maxPeptideMass cp

    indices   = L.findIndices ((fst . digestionRule) cp) (seqdata protein)
    frags     = simpleFragment cp protein (-1:indices)
    splices   = simpleSplice cp frags


--
-- Split a protein at the given amino acid locations. Be sure to include the
-- final fragment, with a dummy cleavage point at the end of the sequence.
--
{-# INLINE simpleFragment #-}
simpleFragment :: (Fractional a, Storable a) => ConfigParams a -> Protein a -> [Int64] -> [Peptide a]
simpleFragment cp p = loop
  where
    loop []                 = []
    loop (i:is) | i+1 > n   = []
                | otherwise = fragment cp p (i+1, n) : loop is
                where
                  l = L.length (seqdata p) - 1
                  n = if null is then l else head is


--
-- Include the possibility of a number of missed cleavages. All combinations of
-- [0..n] sequential peptides are joined. For example, with two missed
-- cleavages:
--      simpleSplice [a,b,c] -> [a,a:b,a:b:c, b,b:c, c]
--
-- The input list must consist of sorted and adjacent breaks of the original
-- protein sequence, but the output is unordered.
--
{-# INLINE simpleSplice   #-}
simpleSplice :: Num a => ConfigParams a -> [Peptide a] -> Vector (Peptide a)
simpleSplice cp = G.fromList . loop
  where
    loop []     = []
    loop (p:ps) = scanl splice p (take n ps) ++ loop ps

    n           = missedCleavages cp
    splice a b  = Peptide
      {
        parent    = parent a,
        residual  = residual a + residual b,
        terminals = (fst (terminals a), snd (terminals b))
      }


--------------------------------------------------------------------------------
-- Pretty printing
--------------------------------------------------------------------------------

--
-- Return a representation of the amino acid sequence of a peptide, including
-- the flanking residuals (if present)
--
slice :: Peptide a -> String
slice peptide = [ca,'.'] ++ (L.unpack (lyse peptide)) ++ ['.',na]
  where
    chain = seqdata (parent peptide)
    (c,n) = terminals peptide
    l     = L.length chain - 2
    ca    = if c > 0 then L.index chain (c-1) else '-'
    na    = if n < l then L.index chain (n+1) else '-'

