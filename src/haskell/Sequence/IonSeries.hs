--------------------------------------------------------------------------------
-- |
-- Module    : Sequence.IonSeries
-- Copyright : (c) 2009 Trevor L. McDonell
-- License   : BSD
--
-- Functions to work with a series of ions, and generate theoretical spectra
-- suitable for matching against experimental results with the sequest
-- cross-correlation algorithm.
--
--------------------------------------------------------------------------------

module Sequence.IonSeries
  (
    matchIons,
    matchIonSequence
  )
  where

import Mass
import Config
import Sequence.Fragment
import Spectrum.Data
import Spectrum.Correlation

import Data.Function
import Data.Vector.Algorithms.Combinators
import Data.Vector.Algorithms.Intro
import qualified Data.ByteString.Lazy.Char8     as L
import qualified Data.Vector.Generic            as G


--
-- Convert mass to mass/charge ratio
--
ionMZ :: Float -> Float -> Float
ionMZ m c = (m + massH*c) / c


--
-- Add a spectral peak for each fragment location, as well as the peaks
-- corresponding to neutral losses of H2O and NH3.
--
-- The factors that contribute to the collision induced dissociation process
-- used in tandem-MS experiments are not completely understood, so accurate
-- prediction of fragment ion abundances are not possible. Magnitude components
-- are assigned based on empirical knowledge.
--
addIonsAB, addIonsY :: Float -> Float -> [(Float, Float)]
addIonsAB charge mass = addIonsA : addIonsB
  where
    addIonsA = let m = ionMZ (mass - massCO) charge in (m, 10)
    addIonsB = let m = ionMZ mass charge in
      [
        (m,50), (m+1,25), (m-1,25),
        (m - massH2O/charge, 10),
        (m - massNH3/charge, 10)
      ]

addIonsY charge mass =
  let m = ionMZ (mass + massH2O) charge in
    [
      (m,50), (m+1,25), (m-1,25),
      (m - massNH3/charge, 10)
    ]


--------------------------------------------------------------------------------
-- Ion Matching
--------------------------------------------------------------------------------

--
-- The mass ladder generated by successive breaks of the peptide backbone from
-- the C- to N-terminus. This also includes the last element, corresponding to
-- the mass of the unbroken peptide, so that the y-ion ladder can be generated
-- from this.
--
-- This does not include neutral loss peaks.
--
bions :: ConfigParams -> Float -> L.ByteString -> [Float]
bions cp charge s = concatMap f [1 .. max 1 (charge-1)]
  where
    f c = map (flip ionMZ c) ms
    ms  = scanl1 (+) . map (getAAMass cp) . L.unpack $ s


--
-- Calculate the number of predicted fragment ions which match the observed
-- spectrum to within 1 da. Returns the number matched together with the total
-- number of ions. This does not consider neutral loss.
--
{-# INLINE matchIons #-}
matchIons :: ConfigParams -> Float -> Spectrum -> Fragment -> (Int, Int)
matchIons cp charge spec (Fragment m _ fd) = (matched, total)
  where
    pep     = L.drop 2 $ L.take (L.length fd - 2) fd
    total   = fromIntegral $ L.length pep * 2 - 2

    ions    = bions cp charge pep
    matched = sum . map (peaks G.!)
                  . filter (\i -> i >= 0 && i < G.length peaks)
                  . map bin
                  $ ions ++ map (m-) ions

    bin x = round (x / binWidth cp / 3)
    zeros = G.replicate (G.length spec `div` 3) 0
    peaks = G.accumulate (\_ _ -> 1) zeros . G.take 200 . apply (sortBy (flip compare `on` snd)) . G.imap (\i v -> (i `div` 3, v)) $ spec


--
-- Calculate the number of predicted fragment ions that match the observed
-- spectrum, together with a record of exactly which ions matched.
--
matchIonSequence :: ConfigParams -> Spectrum -> Fragment -> (Int, Int, [Bool])
matchIonSequence = undefined

