-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "./Foreign/CUDA/Driver/Module.chs" #-}{-# LANGUAGE ForeignFunctionInterface #-}
--------------------------------------------------------------------------------
-- |
-- Module    : Foreign.CUDA.Driver.Module
-- Copyright : (c) [2009..2011] Trevor L. McDonell
-- License   : BSD
--
-- Module management for low-level driver interface
--
--------------------------------------------------------------------------------

module Foreign.CUDA.Driver.Module (

  -- * Module Management
  Module, JITOption(..), JITTarget(..), JITResult(..),
  getFun, getPtr, getTex, loadFile, loadData, loadDataEx, unload

) where


{-# LINE 22 "./Foreign/CUDA/Driver/Module.chs" #-}

-- Friends
import Foreign.CUDA.Ptr
import Foreign.CUDA.Driver.Error
import Foreign.CUDA.Driver.Exec
import Foreign.CUDA.Driver.Marshal              (peekDeviceHandle)
import Foreign.CUDA.Driver.Texture
import Foreign.CUDA.Internal.C2HS

-- System
import Foreign
import Foreign.C
import Unsafe.Coerce

import Control.Monad                            (liftM)
import Control.Exception.Extensible             (throwIO)
import Data.ByteString.Char8                    (ByteString)
import qualified Data.ByteString.Char8          as B


--------------------------------------------------------------------------------
-- Data Types
--------------------------------------------------------------------------------

-- |
-- A reference to a Module object, containing collections of device functions
--
newtype Module = Module { useModule :: ((Ptr ()))}


-- |
-- Just-in-time compilation options
--
data JITOption
  = MaxRegisters       !Int             -- ^ maximum number of registers per thread
  | ThreadsPerBlock    !Int             -- ^ number of threads per block to target for
  | OptimisationLevel  !Int             -- ^ level of optimisation to apply (1-4, default 4)
  | Target             !JITTarget       -- ^ compilation target, otherwise determined from context
--  | FallbackStrategy   JITFallback
  deriving (Show)

-- |
-- Results of online compilation
--
data JITResult = JITResult
  {
    jitTime     :: !Float,              -- ^ milliseconds spent compiling PTX
    jitInfoLog  :: !ByteString,         -- ^ information about PTX asembly
    jitErrorLog :: !ByteString          -- ^ compilation errors
  }
  deriving (Show)


data JITOptionInternal = JIT_MAX_REGISTERS
                       | JIT_THREADS_PER_BLOCK
                       | JIT_WALL_TIME
                       | JIT_INFO_LOG_BUFFER
                       | JIT_INFO_LOG_BUFFER_SIZE_BYTES
                       | JIT_ERROR_LOG_BUFFER
                       | JIT_ERROR_LOG_BUFFER_SIZE_BYTES
                       | JIT_OPTIMIZATION_LEVEL
                       | JIT_TARGET_FROM_CUCONTEXT
                       | JIT_TARGET
                       | JIT_FALLBACK_STRATEGY
                       deriving (Eq,Show)
instance Enum JITOptionInternal where
  fromEnum JIT_MAX_REGISTERS = 0
  fromEnum JIT_THREADS_PER_BLOCK = 1
  fromEnum JIT_WALL_TIME = 2
  fromEnum JIT_INFO_LOG_BUFFER = 3
  fromEnum JIT_INFO_LOG_BUFFER_SIZE_BYTES = 4
  fromEnum JIT_ERROR_LOG_BUFFER = 5
  fromEnum JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6
  fromEnum JIT_OPTIMIZATION_LEVEL = 7
  fromEnum JIT_TARGET_FROM_CUCONTEXT = 8
  fromEnum JIT_TARGET = 9
  fromEnum JIT_FALLBACK_STRATEGY = 10

  toEnum 0 = JIT_MAX_REGISTERS
  toEnum 1 = JIT_THREADS_PER_BLOCK
  toEnum 2 = JIT_WALL_TIME
  toEnum 3 = JIT_INFO_LOG_BUFFER
  toEnum 4 = JIT_INFO_LOG_BUFFER_SIZE_BYTES
  toEnum 5 = JIT_ERROR_LOG_BUFFER
  toEnum 6 = JIT_ERROR_LOG_BUFFER_SIZE_BYTES
  toEnum 7 = JIT_OPTIMIZATION_LEVEL
  toEnum 8 = JIT_TARGET_FROM_CUCONTEXT
  toEnum 9 = JIT_TARGET
  toEnum 10 = JIT_FALLBACK_STRATEGY
  toEnum unmatched = error ("JITOptionInternal.toEnum: Cannot match " ++ show unmatched)

{-# LINE 78 "./Foreign/CUDA/Driver/Module.chs" #-}

data JITTarget = Compute10
               | Compute11
               | Compute12
               | Compute13
               | Compute20
               | Compute21
               | Compute30
               deriving (Eq,Show)
instance Enum JITTarget where
  fromEnum Compute10 = 0
  fromEnum Compute11 = 1
  fromEnum Compute12 = 2
  fromEnum Compute13 = 3
  fromEnum Compute20 = 4
  fromEnum Compute21 = 5
  fromEnum Compute30 = 6

  toEnum 0 = Compute10
  toEnum 1 = Compute11
  toEnum 2 = Compute12
  toEnum 3 = Compute13
  toEnum 4 = Compute20
  toEnum 5 = Compute21
  toEnum 6 = Compute30
  toEnum unmatched = error ("JITTarget.toEnum: Cannot match " ++ show unmatched)

{-# LINE 82 "./Foreign/CUDA/Driver/Module.chs" #-}

data JITFallback = Ptx
                 | Binary
                 deriving (Eq,Show)
instance Enum JITFallback where
  fromEnum Ptx = 0
  fromEnum Binary = 1

  toEnum 0 = Ptx
  toEnum 1 = Binary
  toEnum unmatched = error ("JITFallback.toEnum: Cannot match " ++ show unmatched)

{-# LINE 86 "./Foreign/CUDA/Driver/Module.chs" #-}


--------------------------------------------------------------------------------
-- Module management
--------------------------------------------------------------------------------

-- |
-- Returns a function handle
--
getFun :: Module -> String -> IO Fun
getFun mdl fn = resultIfFound "function" fn =<< cuModuleGetFunction mdl fn

cuModuleGetFunction :: Module -> String -> IO (Status, Fun)
cuModuleGetFunction a2 a3 =
  alloca $ \a1' -> 
  let {a2' = useModule a2} in 
  withCString a3 $ \a3' -> 
  cuModuleGetFunction'_ a1' a2' a3' >>= \res ->
  peekFun  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 102 "./Foreign/CUDA/Driver/Module.chs" #-}
  where peekFun = liftM Fun . peek


-- |
-- Return a global pointer, and size of the global (in bytes)
--
getPtr :: Module -> String -> IO (DevicePtr a, Int)
getPtr mdl name = do
  (status,dptr,bytes) <- cuModuleGetGlobal mdl name
  resultIfFound "global" name (status,(dptr,bytes))

cuModuleGetGlobal :: Module -> String -> IO (Status, DevicePtr a, Int)
cuModuleGetGlobal a3 a4 =
  alloca $ \a1' -> 
  alloca $ \a2' -> 
  let {a3' = useModule a3} in 
  withCString a4 $ \a4' -> 
  cuModuleGetGlobal'_ a1' a2' a3' a4' >>= \res ->
  peekDeviceHandle  a1'>>= \a1'' -> 
  peekIntConv  a2'>>= \a2'' -> 
  let {res' = cToEnum res} in
  return (res', a1'', a2'')
{-# LINE 118 "./Foreign/CUDA/Driver/Module.chs" #-}


-- |
-- Return a handle to a texture reference
--
getTex :: Module -> String -> IO Texture
getTex mdl name = resultIfFound "texture" name =<< cuModuleGetTexRef mdl name

cuModuleGetTexRef :: Module -> String -> IO (Status, Texture)
cuModuleGetTexRef a2 a3 =
  alloca $ \a1' -> 
  let {a2' = useModule a2} in 
  withCString a3 $ \a3' -> 
  cuModuleGetTexRef'_ a1' a2' a3' >>= \res ->
  peekTex  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 130 "./Foreign/CUDA/Driver/Module.chs" #-}


-- |
-- Load the contents of the specified file (either a ptx or cubin file) to
-- create a new module, and load that module into the current context
--
loadFile :: FilePath -> IO Module
loadFile ptx = resultIfOk =<< cuModuleLoad ptx

cuModuleLoad :: FilePath -> IO (Status, Module)
cuModuleLoad a2 =
  alloca $ \a1' -> 
  withCString a2 $ \a2' -> 
  cuModuleLoad'_ a1' a2' >>= \res ->
  peekMod  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 142 "./Foreign/CUDA/Driver/Module.chs" #-}


-- |
-- Load the contents of the given image into a new module, and load that module
-- into the current context. The image (typically) is the contents of a cubin or
-- ptx file as a NULL-terminated string.
--
loadData :: ByteString -> IO Module
loadData img = resultIfOk =<< cuModuleLoadData img

cuModuleLoadData :: ByteString -> IO ( Status, Module)
cuModuleLoadData a2 =
  alloca $ \a1' -> 
  useByteString a2 $ \a2' -> 
  cuModuleLoadData'_ a1' a2' >>= \res ->
  peekMod  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 155 "./Foreign/CUDA/Driver/Module.chs" #-}


-- |
-- Load a module with online compiler options. The actual attributes of the
-- compiled kernel can be probed using 'requires'.
--
loadDataEx :: ByteString -> [JITOption] -> IO (Module, JITResult)
loadDataEx img options =
  allocaArray logSize $ \p_ilog ->
  allocaArray logSize $ \p_elog ->
  let (opt,val) = unzip $
        [ (JIT_WALL_TIME, 0) -- must be first
        , (JIT_INFO_LOG_BUFFER_SIZE_BYTES,  logSize)
        , (JIT_ERROR_LOG_BUFFER_SIZE_BYTES, logSize)
        , (JIT_INFO_LOG_BUFFER,  unsafeCoerce (p_ilog :: CString))
        , (JIT_ERROR_LOG_BUFFER, unsafeCoerce (p_elog :: CString)) ] ++ map unpack options in

  withArray (map cFromEnum opt)    $ \p_opts ->
  withArray (map unsafeCoerce val) $ \p_vals -> do

  (s,mdl) <- cuModuleLoadDataEx img (length opt) p_opts p_vals
  infoLog <- B.packCString p_ilog
  errLog  <- B.packCString p_elog
  time    <- peek (castPtr p_vals)
  resultIfOk (s, (mdl, JITResult time infoLog errLog))

  where
    logSize = 2048

    unpack (MaxRegisters x)      = (JIT_MAX_REGISTERS, x)
    unpack (ThreadsPerBlock x)   = (JIT_THREADS_PER_BLOCK, x)
    unpack (OptimisationLevel x) = (JIT_OPTIMIZATION_LEVEL, x)
    unpack (Target x)            = (JIT_TARGET, fromEnum x)


cuModuleLoadDataEx :: ByteString -> Int -> Ptr CInt -> Ptr (Ptr ()) -> IO (Status, Module)
cuModuleLoadDataEx a2 a3 a4 a5 =
  alloca $ \a1' -> 
  useByteString a2 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  let {a4' = id a4} in 
  let {a5' = id a5} in 
  cuModuleLoadDataEx'_ a1' a2' a3' a4' a5' >>= \res ->
  peekMod  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 196 "./Foreign/CUDA/Driver/Module.chs" #-}


-- |
-- Unload a module from the current context
--
unload :: Module -> IO ()
unload m = nothingIfOk =<< cuModuleUnload m

cuModuleUnload :: Module -> IO (Status)
cuModuleUnload a1 =
  let {a1' = useModule a1} in 
  cuModuleUnload'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 206 "./Foreign/CUDA/Driver/Module.chs" #-}


--------------------------------------------------------------------------------
-- Internal
--------------------------------------------------------------------------------

resultIfFound :: String -> String -> (Status, a) -> IO a
resultIfFound kind name (status,result) =
  case status of
       Success  -> return result
       NotFound -> cudaError (kind ++ ' ' : describe status ++ ": " ++ name)
       _        -> throwIO (ExitCode status)

peekMod :: Ptr ((Ptr ())) -> IO Module
peekMod = liftM Module . peek

useByteString :: ByteString -> (Ptr a -> IO b) -> IO b
useByteString bs act = B.useAsCString bs $ \p -> act (castPtr p)


foreign import ccall unsafe "Foreign/CUDA/Driver/Module.chs.h cuModuleGetFunction"
  cuModuleGetFunction'_ :: ((Ptr (Ptr ())) -> ((Ptr ()) -> ((Ptr CChar) -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Module.chs.h cuModuleGetGlobal"
  cuModuleGetGlobal'_ :: ((Ptr CULLong) -> ((Ptr CULong) -> ((Ptr ()) -> ((Ptr CChar) -> (IO CInt)))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Module.chs.h cuModuleGetTexRef"
  cuModuleGetTexRef'_ :: ((Ptr (Ptr ())) -> ((Ptr ()) -> ((Ptr CChar) -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Module.chs.h cuModuleLoad"
  cuModuleLoad'_ :: ((Ptr (Ptr ())) -> ((Ptr CChar) -> (IO CInt)))

foreign import ccall unsafe "Foreign/CUDA/Driver/Module.chs.h cuModuleLoadData"
  cuModuleLoadData'_ :: ((Ptr (Ptr ())) -> ((Ptr ()) -> (IO CInt)))

foreign import ccall unsafe "Foreign/CUDA/Driver/Module.chs.h cuModuleLoadDataEx"
  cuModuleLoadDataEx'_ :: ((Ptr (Ptr ())) -> ((Ptr ()) -> (CUInt -> ((Ptr CInt) -> ((Ptr (Ptr ())) -> (IO CInt))))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Module.chs.h cuModuleUnload"
  cuModuleUnload'_ :: ((Ptr ()) -> (IO CInt))
