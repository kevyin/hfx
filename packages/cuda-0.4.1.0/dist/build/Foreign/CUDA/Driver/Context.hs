-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "./Foreign/CUDA/Driver/Context.chs" #-}{-# LANGUAGE CPP, ForeignFunctionInterface, EmptyDataDecls #-}
--------------------------------------------------------------------------------
-- |
-- Module    : Foreign.CUDA.Driver.Context
-- Copyright : (c) [2009..2011] Trevor L. McDonell
-- License   : BSD
--
-- Context management for low-level driver interface
--
--------------------------------------------------------------------------------

module Foreign.CUDA.Driver.Context (

  -- * Context Management
  Context(..), ContextFlag(..),
  create, attach, detach, destroy, device, pop, push, sync, get, set,

  -- * Peer Access
  PeerFlag,
  accessible, add, remove,

  -- * Cache Configuration
  Cache(..), Limit(..),
  getLimit, setLimit, setCacheConfig

) where


{-# LINE 30 "./Foreign/CUDA/Driver/Context.chs" #-}

-- Friends
import Foreign.CUDA.Driver.Device       (Device(..))
import Foreign.CUDA.Driver.Error
import Foreign.CUDA.Internal.C2HS

-- System
import Foreign
import Foreign.C
import Control.Monad                    (liftM)


--------------------------------------------------------------------------------
-- Data Types
--------------------------------------------------------------------------------

-- |
-- A device context
--
newtype Context = Context { useContext :: ((Ptr ()))}


-- |
-- Context creation flags
--
data ContextFlag = SchedAuto
                 | SchedSpin
                 | SchedYield
                 | SchedBlockingSync
                 | BlockingSync
                 | SchedMask
                 | MapHost
                 | LmemResizeToMax
                 | FlagsMask
                 deriving (Eq,Show)
instance Enum ContextFlag where
  fromEnum SchedAuto = 0
  fromEnum SchedSpin = 1
  fromEnum SchedYield = 2
  fromEnum SchedBlockingSync = 4
  fromEnum BlockingSync = 4
  fromEnum SchedMask = 7
  fromEnum MapHost = 8
  fromEnum LmemResizeToMax = 16
  fromEnum FlagsMask = 31

  toEnum 0 = SchedAuto
  toEnum 1 = SchedSpin
  toEnum 2 = SchedYield
  toEnum 4 = SchedBlockingSync
  toEnum 4 = BlockingSync
  toEnum 7 = SchedMask
  toEnum 8 = MapHost
  toEnum 16 = LmemResizeToMax
  toEnum 31 = FlagsMask
  toEnum unmatched = error ("ContextFlag.toEnum: Cannot match " ++ show unmatched)

{-# LINE 58 "./Foreign/CUDA/Driver/Context.chs" #-}

-- |
-- Device limits flags
--
data Limit = StackSize
           | PrintfFifoSize
           | MallocHeapSize
           deriving (Eq,Show)
instance Enum Limit where
  fromEnum StackSize = 0
  fromEnum PrintfFifoSize = 1
  fromEnum MallocHeapSize = 2

  toEnum 0 = StackSize
  toEnum 1 = PrintfFifoSize
  toEnum 2 = MallocHeapSize
  toEnum unmatched = error ("Limit.toEnum: Cannot match " ++ show unmatched)

{-# LINE 69 "./Foreign/CUDA/Driver/Context.chs" #-}

-- |
-- Device cache configuration flags
--
data Cache = PreferNone
           | PreferShared
           | PreferL1
           | PreferEqual
           deriving (Eq,Show)
instance Enum Cache where
  fromEnum PreferNone = 0
  fromEnum PreferShared = 1
  fromEnum PreferL1 = 2
  fromEnum PreferEqual = 3

  toEnum 0 = PreferNone
  toEnum 1 = PreferShared
  toEnum 2 = PreferL1
  toEnum 3 = PreferEqual
  toEnum unmatched = error ("Cache.toEnum: Cannot match " ++ show unmatched)

{-# LINE 80 "./Foreign/CUDA/Driver/Context.chs" #-}

-- |
-- Possible option values for direct peer memory access
--
data PeerFlag
instance Enum PeerFlag where


{-# DEPRECATED attach, detach "deprecated as of CUDA-4.0" #-}
{-# DEPRECATED BlockingSync "use SchedBlockingSync instead" #-}


--------------------------------------------------------------------------------
-- Context management
--------------------------------------------------------------------------------

-- |
-- Create a new CUDA context and associate it with the calling thread
--
create :: Device -> [ContextFlag] -> IO Context
create dev flags = resultIfOk =<< cuCtxCreate flags dev

cuCtxCreate :: [ContextFlag] -> Device -> IO (Status, Context)
cuCtxCreate a2 a3 =
  alloca $ \a1' -> 
  let {a2' = combineBitMasks a2} in 
  let {a3' = useDevice a3} in 
  cuCtxCreate'_ a1' a2' a3' >>= \res ->
  peekCtx  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 108 "./Foreign/CUDA/Driver/Context.chs" #-}
  where peekCtx = liftM Context . peek


-- |
-- Increments the usage count of the context. API: no context flags are
-- currently supported, so this parameter must be empty.
--
attach :: Context -> [ContextFlag] -> IO ()
attach ctx flags = nothingIfOk =<< cuCtxAttach ctx flags

cuCtxAttach :: Context -> [ContextFlag] -> IO (Status)
cuCtxAttach a1 a2 =
  withCtx a1 $ \a1' -> 
  let {a2' = combineBitMasks a2} in 
  cuCtxAttach'_ a1' a2' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 121 "./Foreign/CUDA/Driver/Context.chs" #-}
  where withCtx = with . useContext


-- |
-- Detach the context, and destroy if no longer used
--
detach :: Context -> IO ()
detach ctx = nothingIfOk =<< cuCtxDetach ctx

cuCtxDetach :: Context -> IO (Status)
cuCtxDetach a1 =
  let {a1' = useContext a1} in 
  cuCtxDetach'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 132 "./Foreign/CUDA/Driver/Context.chs" #-}


-- |
-- Destroy the specified context. This fails if the context is more than a
-- single attachment (including that from initial creation).
--
destroy :: Context -> IO ()
destroy ctx = nothingIfOk =<< cuCtxDestroy ctx

cuCtxDestroy :: Context -> IO (Status)
cuCtxDestroy a1 =
  let {a1' = useContext a1} in 
  cuCtxDestroy'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 143 "./Foreign/CUDA/Driver/Context.chs" #-}


-- |
-- Return the context bound to the calling CPU thread. Requires cuda-4.0.
--
get :: IO Context
get = resultIfOk =<< cuCtxGetCurrent

cuCtxGetCurrent :: IO (Status, Context)
cuCtxGetCurrent =
  alloca $ \a1' -> 
  cuCtxGetCurrent'_ a1' >>= \res ->
  peekCtx  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 156 "./Foreign/CUDA/Driver/Context.chs" #-}
  where peekCtx = liftM Context . peek


-- |
-- Bind the specified context to the calling thread. Requires cuda-4.0.
--
set :: Context -> IO ()
set ctx = nothingIfOk =<< cuCtxSetCurrent ctx

cuCtxSetCurrent :: Context -> IO (Status)
cuCtxSetCurrent a1 =
  let {a1' = useContext a1} in 
  cuCtxSetCurrent'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 172 "./Foreign/CUDA/Driver/Context.chs" #-}

-- |
-- Return the device of the currently active context
--
device :: IO Device
device = resultIfOk =<< cuCtxGetDevice

cuCtxGetDevice :: IO (Status, Device)
cuCtxGetDevice =
  alloca $ \a1' -> 
  cuCtxGetDevice'_ a1' >>= \res ->
  dev  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 181 "./Foreign/CUDA/Driver/Context.chs" #-}
  where dev = liftM Device . peekIntConv


-- |
-- Pop the current CUDA context from the CPU thread. The context must have a
-- single usage count (matching calls to 'attach' and 'detach'). If successful,
-- the new context is returned, and the old may be attached to a different CPU.
--
pop :: IO Context
pop = resultIfOk =<< cuCtxPopCurrent

cuCtxPopCurrent :: IO (Status, Context)
cuCtxPopCurrent =
  alloca $ \a1' -> 
  cuCtxPopCurrent'_ a1' >>= \res ->
  peekCtx  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 194 "./Foreign/CUDA/Driver/Context.chs" #-}
  where peekCtx = liftM Context . peek


-- |
-- Push the given context onto the CPU's thread stack of current contexts. The
-- context must be floating (via 'pop'), i.e. not attached to any thread.
--
push :: Context -> IO ()
push ctx = nothingIfOk =<< cuCtxPushCurrent ctx

cuCtxPushCurrent :: Context -> IO (Status)
cuCtxPushCurrent a1 =
  let {a1' = useContext a1} in 
  cuCtxPushCurrent'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 206 "./Foreign/CUDA/Driver/Context.chs" #-}


-- |
-- Block until the device has completed all preceding requests
--
sync :: IO ()
sync = nothingIfOk =<< cuCtxSynchronize

cuCtxSynchronize :: IO (Status)
cuCtxSynchronize =
  cuCtxSynchronize'_ >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 216 "./Foreign/CUDA/Driver/Context.chs" #-}


--------------------------------------------------------------------------------
-- Peer access
--------------------------------------------------------------------------------

-- |
-- Queries if the first device can directly access the memory of the second. If
-- direct access is possible, it can then be enabled with 'add'. Requires
-- cuda-4.0.
--
accessible :: Device -> Device -> IO Bool
accessible dev peer = resultIfOk =<< cuDeviceCanAccessPeer dev peer

cuDeviceCanAccessPeer :: Device -> Device -> IO (Status, Bool)
cuDeviceCanAccessPeer a2 a3 =
  alloca $ \a1' -> 
  let {a2' = useDevice a2} in 
  let {a3' = useDevice a3} in 
  cuDeviceCanAccessPeer'_ a1' a2' a3' >>= \res ->
  peekBool  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 238 "./Foreign/CUDA/Driver/Context.chs" #-}


-- |
-- If the devices of both the current and supplied contexts support unified
-- addressing, then enable allocations in the supplied context to be accessible
-- by the current context. Requires cuda-4.0.
--
add :: Context -> [PeerFlag] -> IO ()
add ctx flags = nothingIfOk =<< cuCtxEnablePeerAccess ctx flags

cuCtxEnablePeerAccess :: Context -> [PeerFlag] -> IO (Status)
cuCtxEnablePeerAccess a1 a2 =
  let {a1' = useContext a1} in 
  let {a2' = combineBitMasks a2} in 
  cuCtxEnablePeerAccess'_ a1' a2' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 255 "./Foreign/CUDA/Driver/Context.chs" #-}


-- |
-- Disable direct memory access from the current context to the supplied
-- context. Requires cuda-4.0.
--
remove :: Context -> IO ()
remove ctx = nothingIfOk =<< cuCtxDisablePeerAccess ctx

cuCtxDisablePeerAccess :: Context -> IO (Status)
cuCtxDisablePeerAccess a1 =
  let {a1' = useContext a1} in 
  cuCtxDisablePeerAccess'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 270 "./Foreign/CUDA/Driver/Context.chs" #-}


--------------------------------------------------------------------------------
-- Cache configuration
--------------------------------------------------------------------------------

-- |
-- Query compute 2.0 call stack limits. Requires cuda-3.1.
--
getLimit :: Limit -> IO Int
getLimit l = resultIfOk =<< cuCtxGetLimit l

cuCtxGetLimit :: Limit -> IO (Status, Int)
cuCtxGetLimit a2 =
  alloca $ \a1' -> 
  let {a2' = cFromEnum a2} in 
  cuCtxGetLimit'_ a1' a2' >>= \res ->
  peekIntConv  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 289 "./Foreign/CUDA/Driver/Context.chs" #-}

-- |
-- Specify the size of the call stack, for compute 2.0 devices. Requires
-- cuda-3.1.
--
setLimit :: Limit -> Int -> IO ()
setLimit l n = nothingIfOk =<< cuCtxSetLimit l n

cuCtxSetLimit :: Limit -> Int -> IO (Status)
cuCtxSetLimit a1 a2 =
  let {a1' = cFromEnum a1} in 
  let {a2' = cIntConv a2} in 
  cuCtxSetLimit'_ a1' a2' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 304 "./Foreign/CUDA/Driver/Context.chs" #-}

-- |
-- On devices where the L1 cache and shared memory use the same hardware
-- resources, this sets the preferred cache configuration for the current
-- context. This is only a preference. Requires cuda-3.2.
--
setCacheConfig :: Cache -> IO ()
setCacheConfig c = nothingIfOk =<< cuCtxSetCacheConfig c

cuCtxSetCacheConfig :: Cache -> IO (Status)
cuCtxSetCacheConfig a1 =
  let {a1' = cFromEnum a1} in 
  cuCtxSetCacheConfig'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 319 "./Foreign/CUDA/Driver/Context.chs" #-}


foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxCreate"
  cuCtxCreate'_ :: ((Ptr (Ptr ())) -> (CUInt -> (CInt -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxAttach"
  cuCtxAttach'_ :: ((Ptr (Ptr ())) -> (CUInt -> (IO CInt)))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxDetach"
  cuCtxDetach'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxDestroy"
  cuCtxDestroy'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxGetCurrent"
  cuCtxGetCurrent'_ :: ((Ptr (Ptr ())) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxSetCurrent"
  cuCtxSetCurrent'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxGetDevice"
  cuCtxGetDevice'_ :: ((Ptr CInt) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxPopCurrent"
  cuCtxPopCurrent'_ :: ((Ptr (Ptr ())) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxPushCurrent"
  cuCtxPushCurrent'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxSynchronize"
  cuCtxSynchronize'_ :: (IO CInt)

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuDeviceCanAccessPeer"
  cuDeviceCanAccessPeer'_ :: ((Ptr CInt) -> (CInt -> (CInt -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxEnablePeerAccess"
  cuCtxEnablePeerAccess'_ :: ((Ptr ()) -> (CUInt -> (IO CInt)))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxDisablePeerAccess"
  cuCtxDisablePeerAccess'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxGetLimit"
  cuCtxGetLimit'_ :: ((Ptr CULong) -> (CInt -> (IO CInt)))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxSetLimit"
  cuCtxSetLimit'_ :: (CInt -> (CULong -> (IO CInt)))

foreign import ccall unsafe "Foreign/CUDA/Driver/Context.chs.h cuCtxSetCacheConfig"
  cuCtxSetCacheConfig'_ :: (CInt -> (IO CInt))
