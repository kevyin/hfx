-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "./Foreign/CUDA/Driver/Marshal.chs" #-}{-# LANGUAGE CPP, ForeignFunctionInterface #-}
{-# OPTIONS_HADDOCK prune #-}
--------------------------------------------------------------------------------
-- |
-- Module    : Foreign.CUDA.Driver.Marshal
-- Copyright : (c) [2009..2011] Trevor L. McDonell
-- License   : BSD
--
-- Memory management for low-level driver interface
--
--------------------------------------------------------------------------------

module Foreign.CUDA.Driver.Marshal (

  -- * Host Allocation
  AllocFlag(..),
  mallocHostArray, freeHost, registerArray, unregisterArray,

  -- * Device Allocation
  mallocArray, allocaArray, free,

  -- * Marshalling
  peekArray, peekArrayAsync, peekListArray,
  pokeArray, pokeArrayAsync, pokeListArray,
  copyArrayAsync,
  copyArrayPeer, copyArrayPeerAsync,

  -- * Combined Allocation and Marshalling
  newListArray,  newListArrayLen,
  withListArray, withListArrayLen,

  -- * Utility
  memset, memsetAsync,
  getDevicePtr, getBasePtr, getMemInfo,

  -- Internal
  useDeviceHandle, peekDeviceHandle

) where


{-# LINE 43 "./Foreign/CUDA/Driver/Marshal.chs" #-}

-- Friends
import Foreign.CUDA.Ptr
import Foreign.CUDA.Driver.Error
import Foreign.CUDA.Driver.Stream               (Stream(..))
import Foreign.CUDA.Driver.Context              (Context(..))
import Foreign.CUDA.Internal.C2HS

-- System
import Data.Int
import Data.Maybe
import Unsafe.Coerce
import Control.Applicative
import Control.Exception.Extensible

import Foreign.C
import Foreign.Ptr
import Foreign.Storable
import qualified Foreign.Marshal                as F

--------------------------------------------------------------------------------
-- Host Allocation
--------------------------------------------------------------------------------

-- |
-- Options for host allocation
--
data AllocFlag = Portable
               | DeviceMapped
               | WriteCombined
               deriving (Eq,Show)
instance Enum AllocFlag where
  fromEnum Portable = 1
  fromEnum DeviceMapped = 2
  fromEnum WriteCombined = 4

  toEnum 1 = Portable
  toEnum 2 = DeviceMapped
  toEnum 4 = WriteCombined
  toEnum unmatched = error ("AllocFlag.toEnum: Cannot match " ++ show unmatched)

{-# LINE 82 "./Foreign/CUDA/Driver/Marshal.chs" #-}

-- |
-- Allocate a section of linear memory on the host which is page-locked and
-- directly accessible from the device. The storage is sufficient to hold the
-- given number of elements of a storable type.
--
-- Note that since the amount of pageable memory is thusly reduced, overall
-- system performance may suffer. This is best used sparingly to allocate
-- staging areas for data exchange.
--
mallocHostArray :: Storable a => [AllocFlag] -> Int -> IO (HostPtr a)
mallocHostArray flags = doMalloc undefined
  where
    doMalloc :: Storable a' => a' -> Int -> IO (HostPtr a')
    doMalloc x n = resultIfOk =<< cuMemHostAlloc (n * sizeOf x) flags

cuMemHostAlloc :: Int -> [AllocFlag] -> IO (Status, HostPtr a)
cuMemHostAlloc a2 a3 =
  alloca' $ \a1' -> 
  let {a2' = fromIntegral a2} in 
  let {a3' = combineBitMasks a3} in 
  cuMemHostAlloc'_ a1' a2' a3' >>= \res ->
  peekHP  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 102 "./Foreign/CUDA/Driver/Marshal.chs" #-}
  where
    alloca'  = F.alloca
    peekHP p = (HostPtr . castPtr) `fmap` peek p


-- |
-- Free a section of page-locked host memory
--
freeHost :: HostPtr a -> IO ()
freeHost p = nothingIfOk =<< cuMemFreeHost p

cuMemFreeHost :: HostPtr a -> IO (Status)
cuMemFreeHost a1 =
  let {a1' = useHP a1} in 
  cuMemFreeHost'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 115 "./Foreign/CUDA/Driver/Marshal.chs" #-}
  where
    useHP = castPtr . useHostPtr


-- |
-- Page-locks the specified array (on the host) and maps it for the device(s) as
-- specified by the given allocation flags. Subsequently, the memory is accessed
-- directly by the device so can be read and written with much higher bandwidth
-- than pageable memory that has not been registered. The memory range is added
-- to the same tracking mechanism as 'mallocHostArray' to automatically
-- accelerate calls to functions such as 'pokeArray'.
--
-- Note that page-locking excessive amounts of memory may degrade system
-- performance, since it reduces the amount of pageable memory available. This
-- is best used sparingly to allocate staging areas for data exchange.
--
-- This function is not yet implemented on Mac OS X. Requires cuda-4.0.
--
registerArray :: Storable a => [AllocFlag] -> Int -> Ptr a -> IO (HostPtr a)
registerArray flags n = go undefined
  where
    go :: Storable b => b -> Ptr b -> IO (HostPtr b)
    go x p = do
      status <- cuMemHostRegister p (n * sizeOf x) flags
      resultIfOk (status,HostPtr p)

cuMemHostRegister :: Ptr a -> Int -> [AllocFlag] -> IO (Status)
cuMemHostRegister a1 a2 a3 =
  let {a1' = castPtr a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = combineBitMasks a3} in 
  cuMemHostRegister'_ a1' a2' a3' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 149 "./Foreign/CUDA/Driver/Marshal.chs" #-}


-- |
-- Unmaps the memory from the given pointer, and makes it pageable again.
--
-- This function is not yet implemented on Mac OS X. Requires cuda-4.0.
--
unregisterArray :: HostPtr a -> IO (Ptr a)
unregisterArray (HostPtr p) = do
  status <- cuMemHostUnregister p
  resultIfOk (status,p)

cuMemHostUnregister :: Ptr a -> IO (Status)
cuMemHostUnregister a1 =
  let {a1' = castPtr a1} in 
  cuMemHostUnregister'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 167 "./Foreign/CUDA/Driver/Marshal.chs" #-}


--------------------------------------------------------------------------------
-- Device Allocation
--------------------------------------------------------------------------------

-- |
-- Allocate a section of linear memory on the device, and return a reference to
-- it. The memory is sufficient to hold the given number of elements of storable
-- type. It is suitably aligned for any type, and is not cleared.
--
mallocArray :: Storable a => Int -> IO (DevicePtr a)
mallocArray = doMalloc undefined
  where
    doMalloc :: Storable a' => a' -> Int -> IO (DevicePtr a')
    doMalloc x n = resultIfOk =<< cuMemAlloc (n * sizeOf x)

cuMemAlloc :: Int -> IO (Status, DevicePtr a)
cuMemAlloc a2 =
  alloca' $ \a1' -> 
  let {a2' = fromIntegral a2} in 
  cuMemAlloc'_ a1' a2' >>= \res ->
  peekDeviceHandle  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 187 "./Foreign/CUDA/Driver/Marshal.chs" #-}
  where
    alloca'  = F.alloca


-- |
-- Execute a computation on the device, passing a pointer to a temporarily
-- allocated block of memory sufficient to hold the given number of elements of
-- storable type. The memory is freed when the computation terminates (normally
-- or via an exception), so the pointer must not be used after this.
--
-- Note that kernel launches can be asynchronous, so you may want to add a
-- synchronisation point using 'sync' as part of the computation.
--
allocaArray :: Storable a => Int -> (DevicePtr a -> IO b) -> IO b
allocaArray n = bracket (mallocArray n) free


-- |
-- Release a section of device memory
--
free :: DevicePtr a -> IO ()
free dp = nothingIfOk =<< cuMemFree dp

cuMemFree :: DevicePtr a -> IO (Status)
cuMemFree a1 =
  let {a1' = useDeviceHandle a1} in 
  cuMemFree'_ a1' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 212 "./Foreign/CUDA/Driver/Marshal.chs" #-}


--------------------------------------------------------------------------------
-- Marshalling
--------------------------------------------------------------------------------

-- |
-- Copy a number of elements from the device to host memory. This is a
-- synchronous operation
--
peekArray :: Storable a => Int -> DevicePtr a -> Ptr a -> IO ()
peekArray n dptr hptr = doPeek undefined dptr
  where
    doPeek :: Storable a' => a' -> DevicePtr a' -> IO ()
    doPeek x _ = nothingIfOk =<< cuMemcpyDtoH hptr dptr (n * sizeOf x)

cuMemcpyDtoH :: Ptr a -> DevicePtr a -> Int -> IO (Status)
cuMemcpyDtoH a1 a2 a3 =
  let {a1' = castPtr a1} in 
  let {a2' = useDeviceHandle a2} in 
  let {a3' = fromIntegral a3} in 
  cuMemcpyDtoH'_ a1' a2' a3' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 232 "./Foreign/CUDA/Driver/Marshal.chs" #-}


-- |
-- Copy memory from the device asynchronously, possibly associated with a
-- particular stream. The destination host memory must be page-locked.
--
peekArrayAsync :: Storable a => Int -> DevicePtr a -> HostPtr a -> Maybe Stream -> IO ()
peekArrayAsync n dptr hptr mst = doPeek undefined dptr
  where
    doPeek :: Storable a' => a' -> DevicePtr a' -> IO ()
    doPeek x _ = nothingIfOk =<< cuMemcpyDtoHAsync hptr dptr (n * sizeOf x) (fromMaybe (Stream nullPtr) mst)

cuMemcpyDtoHAsync :: HostPtr a -> DevicePtr a -> Int -> Stream -> IO (Status)
cuMemcpyDtoHAsync a1 a2 a3 a4 =
  let {a1' = useHP a1} in 
  let {a2' = useDeviceHandle a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = useStream a4} in 
  cuMemcpyDtoHAsync'_ a1' a2' a3' a4' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 249 "./Foreign/CUDA/Driver/Marshal.chs" #-}
  where
    useHP = castPtr . useHostPtr


-- |
-- Copy a number of elements from the device into a new Haskell list. Note that
-- this requires two memory copies: firstly from the device into a heap
-- allocated array, and from there marshalled into a list.
--
peekListArray :: Storable a => Int -> DevicePtr a -> IO [a]
peekListArray n dptr =
  F.allocaArray n $ \p -> do
    peekArray   n dptr p
    F.peekArray n p


-- |
-- Copy a number of elements onto the device. This is a synchronous operation
--
pokeArray :: Storable a => Int -> Ptr a -> DevicePtr a -> IO ()
pokeArray n hptr dptr = doPoke undefined dptr
  where
    doPoke :: Storable a' => a' -> DevicePtr a' -> IO ()
    doPoke x _ = nothingIfOk =<< cuMemcpyHtoD dptr hptr (n * sizeOf x)

cuMemcpyHtoD :: DevicePtr a -> Ptr a -> Int -> IO (Status)
cuMemcpyHtoD a1 a2 a3 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = castPtr a2} in 
  let {a3' = fromIntegral a3} in 
  cuMemcpyHtoD'_ a1' a2' a3' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 278 "./Foreign/CUDA/Driver/Marshal.chs" #-}


-- |
-- Copy memory onto the device asynchronously, possibly associated with a
-- particular stream. The source host memory must be page-locked.
--
pokeArrayAsync :: Storable a => Int -> HostPtr a -> DevicePtr a -> Maybe Stream -> IO ()
pokeArrayAsync n hptr dptr mst = dopoke undefined dptr
  where
    dopoke :: Storable a' => a' -> DevicePtr a' -> IO ()
    dopoke x _ = nothingIfOk =<< cuMemcpyHtoDAsync dptr hptr (n * sizeOf x) (fromMaybe (Stream nullPtr) mst)

cuMemcpyHtoDAsync :: DevicePtr a -> HostPtr a -> Int -> Stream -> IO (Status)
cuMemcpyHtoDAsync a1 a2 a3 a4 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = useHP a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = useStream a4} in 
  cuMemcpyHtoDAsync'_ a1' a2' a3' a4' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 295 "./Foreign/CUDA/Driver/Marshal.chs" #-}
  where
    useHP = castPtr . useHostPtr


-- |
-- Write a list of storable elements into a device array. The device array must
-- be sufficiently large to hold the entire list. This requires two marshalling
-- operations.
--
pokeListArray :: Storable a => [a] -> DevicePtr a -> IO ()
pokeListArray xs dptr = F.withArrayLen xs $ \len p -> pokeArray len p dptr


-- |
-- Copy the given number of elements from the first device array (source) to the
-- second (destination). The copied areas may not overlap. This operation is
-- asynchronous with respect to the host, but will never overlap with kernel
-- execution.
--
copyArrayAsync :: Storable a => Int -> DevicePtr a -> DevicePtr a -> IO ()
copyArrayAsync n = docopy undefined
  where
    docopy :: Storable a' => a' -> DevicePtr a' -> DevicePtr a' -> IO ()
    docopy x src dst = nothingIfOk =<< cuMemcpyDtoD dst src (n * sizeOf x)

cuMemcpyDtoD :: DevicePtr a -> DevicePtr a -> Int -> IO (Status)
cuMemcpyDtoD a1 a2 a3 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = useDeviceHandle a2} in 
  let {a3' = fromIntegral a3} in 
  cuMemcpyDtoD'_ a1' a2' a3' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 324 "./Foreign/CUDA/Driver/Marshal.chs" #-}


-- |
-- Copies an array from device memory in one context to device memory in another
-- context. Note that this function is asynchronous with respect to the host,
-- but serialised with respect to all pending and future asynchronous work in
-- the source and destination contexts. To avoid this synchronisation, use
-- 'copyArrayPeerAsync' instead.
--
copyArrayPeer :: Storable a
              => Int                            -- ^ number of array elements
              -> DevicePtr a -> Context         -- ^ source array and context
              -> DevicePtr a -> Context         -- ^ destination array and context
              -> IO ()
copyArrayPeer n src srcCtx dst dstCtx = go undefined src dst
  where
    go :: Storable b => b -> DevicePtr b -> DevicePtr b -> IO ()
    go x _ _ = nothingIfOk =<< cuMemcpyPeer dst dstCtx src srcCtx (n * sizeOf x)

cuMemcpyPeer :: DevicePtr a -> Context -> DevicePtr a -> Context -> Int -> IO (Status)
cuMemcpyPeer a1 a2 a3 a4 a5 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = useContext a2} in 
  let {a3' = useDeviceHandle a3} in 
  let {a4' = useContext a4} in 
  let {a5' = fromIntegral a5} in 
  cuMemcpyPeer'_ a1' a2' a3' a4' a5' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 353 "./Foreign/CUDA/Driver/Marshal.chs" #-}


-- |
-- Copies from device memory in one context to device memory in another context.
-- Note that this function is asynchronous with respect to the host and all work
-- in other streams and devices.
--
copyArrayPeerAsync :: Storable a
                   => Int                       -- ^ number of array elements
                   -> DevicePtr a -> Context    -- ^ source array and context
                   -> DevicePtr a -> Context    -- ^ destination array and device context
                   -> Maybe Stream              -- ^ stream to associate with
                   -> IO ()
copyArrayPeerAsync n src srcCtx dst dstCtx st = go undefined src dst
  where
    go :: Storable b => b -> DevicePtr b -> DevicePtr b -> IO ()
    go x _ _ = nothingIfOk =<< cuMemcpyPeerAsync dst dstCtx src srcCtx (n * sizeOf x) stream
    stream   = fromMaybe (Stream nullPtr) st

cuMemcpyPeerAsync :: DevicePtr a -> Context -> DevicePtr a -> Context -> Int -> Stream -> IO (Status)
cuMemcpyPeerAsync a1 a2 a3 a4 a5 a6 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = useContext a2} in 
  let {a3' = useDeviceHandle a3} in 
  let {a4' = useContext a4} in 
  let {a5' = fromIntegral a5} in 
  let {a6' = useStream a6} in 
  cuMemcpyPeerAsync'_ a1' a2' a3' a4' a5' a6' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 383 "./Foreign/CUDA/Driver/Marshal.chs" #-}


--------------------------------------------------------------------------------
-- Combined Allocation and Marshalling
--------------------------------------------------------------------------------

-- |
-- Write a list of storable elements into a newly allocated device array,
-- returning the device pointer together with the number of elements that were
-- written. Note that this requires two memory copies: firstly from a Haskell
-- list to a heap allocated array, and from there onto the graphics device. The
-- memory should be 'free'd when no longer required.
--
newListArrayLen :: Storable a => [a] -> IO (DevicePtr a, Int)
newListArrayLen xs =
  F.withArrayLen xs                     $ \len p ->
  bracketOnError (mallocArray len) free $ \d_xs  -> do
    pokeArray len p d_xs
    return (d_xs, len)


-- |
-- Write a list of storable elements into a newly allocated device array. This
-- is 'newListArrayLen' composed with 'fst'.
--
newListArray :: Storable a => [a] -> IO (DevicePtr a)
newListArray xs = fst `fmap` newListArrayLen xs


-- |
-- Temporarily store a list of elements into a newly allocated device array. An
-- IO action is applied to to the array, the result of which is returned.
-- Similar to 'newListArray', this requires copying the data twice.
--
-- As with 'allocaArray', the memory is freed once the action completes, so you
-- should not return the pointer from the action, and be wary of asynchronous
-- kernel execution.
--
withListArray :: Storable a => [a] -> (DevicePtr a -> IO b) -> IO b
withListArray xs = withListArrayLen xs . const


-- |
-- A variant of 'withListArray' which also supplies the number of elements in
-- the array to the applied function
--
withListArrayLen :: Storable a => [a] -> (Int -> DevicePtr a -> IO b) -> IO b
withListArrayLen xs f =
  bracket (newListArrayLen xs) (free . fst) (uncurry . flip $ f)
--
-- XXX: Will this attempt to double-free the device array on error (together
-- with newListArrayLen)?
--


--------------------------------------------------------------------------------
-- Utility
--------------------------------------------------------------------------------

-- |
-- Set a number of data elements to the specified value, which may be either 8-,
-- 16-, or 32-bits wide.
--
memset :: Storable a => DevicePtr a -> Int -> a -> IO ()
memset dptr n val = case sizeOf val of
    1 -> nothingIfOk =<< cuMemsetD8  dptr val n
    2 -> nothingIfOk =<< cuMemsetD16 dptr val n
    4 -> nothingIfOk =<< cuMemsetD32 dptr val n
    _ -> cudaError "can only memset 8-, 16-, and 32-bit values"

--
-- We use unsafe coerce below to reinterpret the bits of the value to memset as,
-- into the integer type required by the setting functions.
--
cuMemsetD8 :: DevicePtr a -> a -> Int -> IO (Status)
cuMemsetD8 a1 a2 a3 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = unsafeCoerce a2} in 
  let {a3' = fromIntegral a3} in 
  cuMemsetD8'_ a1' a2' a3' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 461 "./Foreign/CUDA/Driver/Marshal.chs" #-}

cuMemsetD16 :: DevicePtr a -> a -> Int -> IO (Status)
cuMemsetD16 a1 a2 a3 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = unsafeCoerce a2} in 
  let {a3' = fromIntegral a3} in 
  cuMemsetD16'_ a1' a2' a3' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 466 "./Foreign/CUDA/Driver/Marshal.chs" #-}

cuMemsetD32 :: DevicePtr a -> a -> Int -> IO (Status)
cuMemsetD32 a1 a2 a3 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = unsafeCoerce a2} in 
  let {a3' = fromIntegral a3} in 
  cuMemsetD32'_ a1' a2' a3' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 471 "./Foreign/CUDA/Driver/Marshal.chs" #-}


-- |
-- Set the number of data elements to the specified value, which may be either
-- 8-, 16-, or 32-bits wide. The operation is asynchronous and may optionally be
-- associated with a stream. Requires cuda-3.2.
--
memsetAsync :: Storable a => DevicePtr a -> Int -> a -> Maybe Stream -> IO ()
memsetAsync dptr n val mst = case sizeOf val of
    1 -> nothingIfOk =<< cuMemsetD8Async  dptr val n stream
    2 -> nothingIfOk =<< cuMemsetD16Async dptr val n stream
    4 -> nothingIfOk =<< cuMemsetD32Async dptr val n stream
    _ -> cudaError "can only memset 8-, 16-, and 32-bit values"
    where
      stream = fromMaybe (Stream nullPtr) mst

cuMemsetD8Async :: DevicePtr a -> a -> Int -> Stream -> IO (Status)
cuMemsetD8Async a1 a2 a3 a4 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = unsafeCoerce a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = useStream a4} in 
  cuMemsetD8Async'_ a1' a2' a3' a4' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 495 "./Foreign/CUDA/Driver/Marshal.chs" #-}

cuMemsetD16Async :: DevicePtr a -> a -> Int -> Stream -> IO (Status)
cuMemsetD16Async a1 a2 a3 a4 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = unsafeCoerce a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = useStream a4} in 
  cuMemsetD16Async'_ a1' a2' a3' a4' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 501 "./Foreign/CUDA/Driver/Marshal.chs" #-}

cuMemsetD32Async :: DevicePtr a -> a -> Int -> Stream -> IO (Status)
cuMemsetD32Async a1 a2 a3 a4 =
  let {a1' = useDeviceHandle a1} in 
  let {a2' = unsafeCoerce a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = useStream a4} in 
  cuMemsetD32Async'_ a1' a2' a3' a4' >>= \res ->
  let {res' = cToEnum res} in
  return (res')
{-# LINE 508 "./Foreign/CUDA/Driver/Marshal.chs" #-}


-- |
-- Return the device pointer associated with a mapped, pinned host buffer, which
-- was allocated with the 'DeviceMapped' option by 'mallocHostArray'.
--
-- Currently, no options are supported and this must be empty.
--
getDevicePtr :: [AllocFlag] -> HostPtr a -> IO (DevicePtr a)
getDevicePtr flags hp = resultIfOk =<< cuMemHostGetDevicePointer hp flags

cuMemHostGetDevicePointer :: HostPtr a -> [AllocFlag] -> IO (Status, DevicePtr a)
cuMemHostGetDevicePointer a2 a3 =
  alloca' $ \a1' -> 
  let {a2' = useHP a2} in 
  let {a3' = combineBitMasks a3} in 
  cuMemHostGetDevicePointer'_ a1' a2' a3' >>= \res ->
  peekDeviceHandle  a1'>>= \a1'' -> 
  let {res' = cToEnum res} in
  return (res', a1'')
{-# LINE 523 "./Foreign/CUDA/Driver/Marshal.chs" #-}
  where
    alloca'  = F.alloca
    useHP    = castPtr . useHostPtr

-- |
-- Return the base address and allocation size of the given device pointer
--
getBasePtr :: DevicePtr a -> IO (DevicePtr a, Int64)
getBasePtr dptr = do
  (status,base,size) <- cuMemGetAddressRange dptr
  resultIfOk (status, (base,size))

cuMemGetAddressRange :: DevicePtr a -> IO (Status, DevicePtr a, Int64)
cuMemGetAddressRange a3 =
  alloca' $ \a1' -> 
  alloca' $ \a2' -> 
  let {a3' = useDeviceHandle a3} in 
  cuMemGetAddressRange'_ a1' a2' a3' >>= \res ->
  peekDeviceHandle  a1'>>= \a1'' -> 
  peekIntConv  a2'>>= \a2'' -> 
  let {res' = cToEnum res} in
  return (res', a1'', a2'')
{-# LINE 539 "./Foreign/CUDA/Driver/Marshal.chs" #-}
  where
    alloca' :: Storable a => (Ptr a -> IO b) -> IO b
    alloca' = F.alloca

-- |
-- Return the amount of free and total memory respectively available to the
-- current context (bytes)
--
getMemInfo :: IO (Int64, Int64)
getMemInfo = do
  (status,f,t) <- cuMemGetInfo
  resultIfOk (status,(f,t))

cuMemGetInfo :: IO (Status, Int64, Int64)
cuMemGetInfo =
  alloca' $ \a1' -> 
  alloca' $ \a2' -> 
  cuMemGetInfo'_ a1' a2' >>= \res ->
  peekIntConv  a1'>>= \a1'' -> 
  peekIntConv  a2'>>= \a2'' -> 
  let {res' = cToEnum res} in
  return (res', a1'', a2'')
{-# LINE 555 "./Foreign/CUDA/Driver/Marshal.chs" #-}
  where
    alloca' = F.alloca


--------------------------------------------------------------------------------
-- Internal
--------------------------------------------------------------------------------

type DeviceHandle = (CULLong)
{-# LINE 564 "./Foreign/CUDA/Driver/Marshal.chs" #-}

-- Lift an opaque handle to a typed DevicePtr representation. This occasions
-- arcane distinctions for the different driver versions and Tesla (compute 1.x)
-- and Fermi (compute 2.x) class architectures on 32- and 64-bit hosts.
--
peekDeviceHandle :: Ptr DeviceHandle -> IO (DevicePtr a)
peekDeviceHandle p = DevicePtr . intPtrToPtr . fromIntegral <$> peek p

-- Use a device pointer as an opaque handle type
--
useDeviceHandle :: DevicePtr a -> DeviceHandle
useDeviceHandle = fromIntegral . ptrToIntPtr . useDevicePtr


foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemHostAlloc"
  cuMemHostAlloc'_ :: ((Ptr (Ptr ())) -> (CULong -> (CUInt -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemFreeHost"
  cuMemFreeHost'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemHostRegister"
  cuMemHostRegister'_ :: ((Ptr ()) -> (CULong -> (CUInt -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemHostUnregister"
  cuMemHostUnregister'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemAlloc"
  cuMemAlloc'_ :: ((Ptr CULLong) -> (CULong -> (IO CInt)))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemFree"
  cuMemFree'_ :: (CULLong -> (IO CInt))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemcpyDtoH"
  cuMemcpyDtoH'_ :: ((Ptr ()) -> (CULLong -> (CULong -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemcpyDtoHAsync"
  cuMemcpyDtoHAsync'_ :: ((Ptr ()) -> (CULLong -> (CULong -> ((Ptr ()) -> (IO CInt)))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemcpyHtoD"
  cuMemcpyHtoD'_ :: (CULLong -> ((Ptr ()) -> (CULong -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemcpyHtoDAsync"
  cuMemcpyHtoDAsync'_ :: (CULLong -> ((Ptr ()) -> (CULong -> ((Ptr ()) -> (IO CInt)))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemcpyDtoD"
  cuMemcpyDtoD'_ :: (CULLong -> (CULLong -> (CULong -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemcpyPeer"
  cuMemcpyPeer'_ :: (CULLong -> ((Ptr ()) -> (CULLong -> ((Ptr ()) -> (CULong -> (IO CInt))))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemcpyPeerAsync"
  cuMemcpyPeerAsync'_ :: (CULLong -> ((Ptr ()) -> (CULLong -> ((Ptr ()) -> (CULong -> ((Ptr ()) -> (IO CInt)))))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemsetD8"
  cuMemsetD8'_ :: (CULLong -> (CUChar -> (CULong -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemsetD16"
  cuMemsetD16'_ :: (CULLong -> (CUShort -> (CULong -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemsetD32"
  cuMemsetD32'_ :: (CULLong -> (CUInt -> (CULong -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemsetD8Async"
  cuMemsetD8Async'_ :: (CULLong -> (CUChar -> (CULong -> ((Ptr ()) -> (IO CInt)))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemsetD16Async"
  cuMemsetD16Async'_ :: (CULLong -> (CUShort -> (CULong -> ((Ptr ()) -> (IO CInt)))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemsetD32Async"
  cuMemsetD32Async'_ :: (CULLong -> (CUInt -> (CULong -> ((Ptr ()) -> (IO CInt)))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemHostGetDevicePointer"
  cuMemHostGetDevicePointer'_ :: ((Ptr CULLong) -> ((Ptr ()) -> (CUInt -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemGetAddressRange"
  cuMemGetAddressRange'_ :: ((Ptr CULLong) -> ((Ptr CULong) -> (CULLong -> (IO CInt))))

foreign import ccall unsafe "Foreign/CUDA/Driver/Marshal.chs.h cuMemGetInfo"
  cuMemGetInfo'_ :: ((Ptr CULong) -> ((Ptr CULong) -> (IO CInt)))
